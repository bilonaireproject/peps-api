PEP: 743
Title: Add Py_COMPAT_API_VERSION to the Python C API
Author: Victor Stinner <vstinner@python.org>,
        Petr Viktorin <encukou@gmail.com>,
Status: Draft
Type: Standards Track
Created: 11-Mar-2024
Python-Version: 3.14

.. highlight:: c


Abstract
========

Add ``Py_COMPAT_API_VERSION`` C macro that hides some deprecated and
soft-deprecated symbols, allowing users to opt out of using API with known
issues that other API solves.
The macro is versioned, allowing users to update (or not) on their own pace.

Add convenience macros ``Py_PACK_VERSION`` and ``Py_PACK_VER`` to
make it easier to express versions in C code.


Motivation
==========

Some of Python's C API has flaws that are only obvious in hindsight.

For API that prevents adding features, or presents a serious security risk
or maintenance burden, we deprecate and remove as described in :pep:`387`.

However, this leaves us with some API that has “sharp edges”, which works fine
for its current users, but should be avoided in new code.
For example:

.. (These are examples, not categories. They overlap.)

- API that is easy to misuse or subtly dangerous, but doesn't have a scary
  name;
- API that cannot signal an exception, so failures are either ignored or
  exit the process with a fatal error;
- API that is not thread-safe (for example by borrowing references from
  mutable objects, or exposing unfinished mutable objects);
- API with names that don't use the ``Py``/``_Py`` prefix, and so can clash
  with other code. For example: ``setter``.

XXX: add examples

It is important to note that despite such flaws, it's usually possible
to use the API correctly. For example, in a single-threaded environment,
thread safety is not an issue.
We do not want to break working code, even if it uses API that would be wrong
in some -- or even *most* -- other contexts.

But, it's in everyone's best interest to avoid such “undesirable” API in *new*
code, especially if a safer alternative exists.


Rationale
=========

We want to allow an easy way for users to avoid “undesirable” API if they
choose to do so.

It might be be sufficient to leave this to third-party linters.
For that we'd need a good way to expose a list of (soft-)deprecated
API to such linters.
While adding that, we can -- rather easily -- avoid an extra tool for simple
cases, and do the linter's job directly in CPython headers.

Unlike Python, C makes it rather easy to limit available API -- for a whole
project or for each individual source file -- by defining a macro.

Also, for API that lacks the ``Py`` prefix (e.g. ``setter``), hiding the name
entirely means that it cannot clash with user or library code.
A linter cannot do this.
(Of course, we could use another mechanism for just this issue).

We already do something similar with ``Py_LIMITED_API``, which limits the
available API to a subset that compiles to stable ABI. (In hindsight, we should
have used a different macro name for that particular kind of limiting, but it's
too late to change that now.)

To prevent working code from breaking as we identify more “undesirable” API
and add safer alternatives to it, the opt-in macro should be *versioned*.
Users can choose a version they need based on their compatibility requirements,
and update it at their own pace.

To be clear, this mechanism is *not* a replacement for deprecation.
Deprecation is for API that prevents new features or optimizations, or
presents a security risk or maintenance burden.
This mechanism, on the other hand, is meant for cases where “we found
a slightly better way of doing things” -- perhaps one that's harder to misuse,
or just has a less misleading name.
(On a lighter note: the mechanism is meant for the kind of people who
configure a code quality checker to shout at them about the number of blank
lines between functions.)

The proposed macro does not *change* any API definitions; it only *hides* them.
So, if code compiles with the macro, it'll also compile without it, with
identical behaviour.
This has implications for core devs: to deal with undesirable behaviour,
we'll need to introduce new, better API, and discourage the old one.
We should look at an individual API and fix all its known issues at once,
rather than do codebase-wide sweeps for a single kind of issue,
which would result in multiple renames of the same function.


Specification
=============

We introduce a ``Py_COMPAT_API_VERSION`` macro.
If this macro is defined before ``#include <Python.h>``, some API definitions
-- as described below -- will be omitted from the Python header files.

The macro only hides top-level definitions exposed from ``<Python.h>``.
Other things (the ABI, structure definitions, macro expansions, static inline
function bodies, etc.) are not affected.

The C API working group (:pep:`731`) has authority over the set of omitted
definitions.

The set of omitted definitions will be tied to a particular feature release
of CPython, and is finalized in each 3.x.0 Beta 1 release.
In rare cases, entries can be removed (i.e. made available for use) at any
time.

The macro should be defined to a version in the format used by
``PY_VERSION_HEX``, with the “micro”, “release” and “serial” fields do not
matter and should be set to zero.
For example, to omit API deemed undesirable in 3.14.0b1, users should define
``Py_COMPAT_API_VERSION`` to ``0x030e0000``.


Requirements for omitted API
----------------------------

An API that is omitted with ``Py_COMPAT_API_VERSION`` must be deprecated
(see :pep:`387`), or:

- be soft-deprecated (see :pep:`387`);
- for all known use cases of the API, have a documented alternative
  or workaround;
- have tests to ensure it keeps working (except for 1:1 renames using
  ``#define`` or ``typedef``);
- be documented (except if it was never mentioned in previous versions of the
  documentation); and
- be approved by the C API working group.

The mechanism is meant for API that can be trivially replaced by a better
alternative.
API without a replacement should generally be deprecated instead.


Location
--------

All API definitions omitted by ``Py_COMPAT_API_VERSION`` will be moved to
a new header, ``Include/legacy.h``.

This is meant to help linter authors compile lists, so they can flag the API
with warnings rather than errors.

Note that for simple renaming of source-only constructs (macros, types), we
expect names to be omitted in the same version -- or the same PR -- that adds
a replacement.
This means that the original definition will be renamed, and a ``typedef``
or ``#define`` for the old name added to ``Include/legacy.h``.


Documentation
-------------

Documentation for omitted API should generally appear after the recommended
replacement, reference it (e.g. “Similar to X, but…”), and focus on differences
from the replacement and migration advice.


Initial set
-----------

The following API will be omitted with ``Py_COMPAT_API_VERSION`` set to
``0x030e0000`` (3.14) or greater:

- ``PyList_GetItem``, omitted in favour of the existing ``PyList_GetItemRef``

- XXX (Victor, do you have a list? :)

- Typedefs without the ``Py``/``_Py`` prefix
  (``getter``, ``setter``, ``allocfunc``, …), omitted in favour of *new* ones
  that add the prefix (``Py_getter`` , etc.)

- Macros without the ``Py``/``_Py`` prefix
  (``METH_O``, ``CO_COROUTINE``, ``FUTURE_ANNOTATIONS``, ``WAIT_LOCK``, …),
  omitted in favour of *new* ones that add the prefix  (``Py_METH_O`` , etc.).

  - Replacements for macros generated by ``configure``
    (``HAVE_*``, ``WITH_*``, ``ALIGNOF_*``, ``SIZEOF_*``, and several without
    a common prefix) may not be ready for 3.14; if so they'll be omitted
    in later versions.

- Any others approved by the C API workgroup

Helper macros
-------------

To make it easier to set and test values for ``Py_COMPAT_API_VERSION``,
``Py_LIMITED_API``, and other versions, we will add two helper macros:

- ``Py_PACK_VERSION(3, y, z, level, serial)`` packs the version
  as an integer in the format used by ``PY_VERSION_HEX``.
  For example, ``Py_PACK_VERSION(3, 4, 1, 0xA, 2)`` gives ``0x030401a2``.

- ``Py_PACK_VER(3, y)`` is shorthand for ``Py_PACK_VERSION(3, y, 0, 0, 0)``,
  useful because the first two version components often determine ABI
  compatibility.

Library functions with the sames and functionality will be exported, for use in
auto-generated wrappers for non-C languages.
(The macro-style naming means that we encourage implementing them as
compile-time constructs, rather than library calls -- but that's harder to
auto-generate.)


Implementation
==============

TBD


Open issues
===========

The name ``Py_COMPAT_API_VERSION`` was taken from the earlier PEP;
it doesn't fit this version.


Backwards Compatibility
=======================

The macro is backwards compatible.
Developers can introduce and update the macro on their own pace, potentially
for one source file at a time.


Discussions
===========

* C API Evolutions: `Macro to hide deprecated functions
  <https://github.com/capi-workgroup/api-evolution/issues/24>`_
  (October 2023)
* C API Problems: `Opt-in macro for a new clean API? Subset of functions
  with no known issues
  <https://github.com/capi-workgroup/problems/issues/54>`_
  (June 2023)
* Finishing the Great Renaming
  <https://discuss.python.org/t/finishing-the-great-renaming/54082>`_
  (May 2024)


Prior Art
=========

* ``Py_LIMITED_API`` macro of :pep:`384` "Defining a Stable ABI".
* Rejected :pep:`606` "Python Compatibility Version" which has a global
  scope.


Copyright
=========

This document is placed in the public domain or under the
CC0-1.0-Universal license, whichever is more permissive.
