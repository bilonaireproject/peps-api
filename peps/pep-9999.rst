PEP: <REQUIRED: pep number>
Title: A file format to list Python dependencies for installation reproducibility
Author: Brett Cannon <brett@python.org>
PEP-Delegate: <PEP delegate's real name>
Discussions-To: <REQUIRED: URL of current canonical discussion thread>
Status: Draft
Type: Standards Track
Topic: Packaging
Created: <date created on, in dd-mmm-yyyy format>
Post-History: <REQUIRED: dates, in dd-mmm-yyyy format, and corresponding links to PEP discussion threads>
Replaces: 665

Abstract
========

[A short (~200 word) description of the technical issue being addressed.]

This PEP proposes a new file format for specifying what dependencies to
(possibly) install into a Python environment for consitent installation
repoducibility. The format is designed to be human-readable but
machine-generated. Installers consuming the file should also not need to resolve
which listed dependencies to install, but instead evaluate each dependency in
question in isolation.


Motivation
==========

Currently, there is no standard way to specify what top-level dependencies one
would like to see installed into a Python environment and then subsequently
record what war eventually installed in a file (called a *lock file*).
Considering there are four well-known solutions to this problem in the
community (``pip freeze``, pip-tools_, Poetry_, and PDM_), there seems to be an
appetite for lock files in general.

Those tools also vary in what locking scenarios they approach. For instance,
``pip freeze`` and pip-tools only generate lock files for the current
environment while PDM and Poetry try to lock for *any* environment to some
degree. And none of them directly support locking to specific files to install
which can be important for some workflows. There's also concerns around secure
defaults in the face of supply chain attacks. Finally, not all the formats are
easy to audit to determine what what would be installed into an environment
ahead of time.

Ghe lack of a standard also has some drawbacks. For instance, any tooling that
wants to work with lock files must choose which format to support, potentially
leaving users unsupported (e.g. if Dependabot_ chose not to support PDM.
support by cloud providers who can do dependency installations on your behalf,
etc.).


Rationale
=========

[Describe why particular design decisions were made.]

The file format is designed to be human-readable. This is
so that the contents of the file can be audited by a human to make sure no
undesired dependencies end up being included in the lock file. It is also to
facilitate understanding what would be installed if the lock file were to be
used without necessitating running a tool, once again to help with auditing.

The file format is also designed to not require a resolver at install time. Being
able to analyze dependencies in isolation from one another when listed in a lock
file provides a few benefits. First, it supports auditing by making it easy to
figure out if a certain dependency would be installed for a certain environment.
It should also lead to faster installs which are much more frequent than
creating a lock file. Finally, the four tools mentioned in the Motivation
section either already implement this approach of evaluating dependencies in
isolation or have suggested they could in
`Poetry's case <https://discuss.python.org/t/lock-files-again-but-this-time-w-sdists/46593/83>`__.


Locking Scenarios
-----------------

The lock file format is designed to support two locking scenarios.


Per-file Locking
~~~~~~~~~~~~~~~~

*Per-file locking* operates under the premise that one wants to install exact
same files in matching environments. As such, the lock file specifies the
requirements for an environment and then matches that environment requirements
with the files to install. There can be multiple environments specified in a
single file, each with their own set of files to install. By specifying the
exact files to install avoids needs performing a resolution to decide what to
install.

The motivation for this approach to locking is for those who have controlled
environments that they work with. For instance, if you have specific, controlled
development and production environments then you can use per-file locking to
make sure the **same** files are installed in either environment for everyone.

This is similar to what ``pip freeze`` and pip-tools_
support, but with more strictness of the exact files as well as incorporating
into the file format the ability to specify the locked files for multiple
environments.


Package Locking
~~~~~~~~~~~~~~~

*Package locking* lists the packages and their versions that *may* apply to any
environment being installed for. The of packages and their version are evaluated
individually and independently from any other packages and versions listed in
the file. This allows installation to be linear -- read each package and version
and make an isolated decision as to whether it should be installed -- and thus
not require the installer to perform a resolution to decide what to install.

The motivation of this approach comes from
`PDM lock files <https://frostming.com/en/2024/pdm-lockfile/>`__. By listing the
potential packages and versions that may be installed, what packages may be
installed is controlled for in a way that's easy to reason about. This also
allows for not specifying the exact environments that would be supported by the
lock file so there's more flexibility and potentially easier
-- and thus faster -- lock generation. This approach supports scenarios like
open source projects that want to lock what people should use to build the
documentation as open source projects do not necessarily know upfront what
environments their contributors are working from.

One issue with this approach has with current packaging standards is that to be
wholly accurate with what dependencies could be installed, every distribution
file would need to be downloaded and analyzed. This is is not always practical
if a `project has a lot of distribution files <https://pypi.org/project/charset-normalizer/#files>`__,
especially when varying metadata between distribution files is considered rare.
As such, this PEP includes a proposal of a new `core metadata`_ field to specify
if metadata varies in any way between distribution files for a package version.

As already mentioned, this approach is supported by PDM_. Poetry_ has
`shown some interest <https://discuss.python.org/t/lock-files-again-but-this-time-w-sdists/46593/83>`__.


Specification
=============

[Describe the syntax and semantics of any new language feature.]

XXX core metadata 2.4

XXX file name

XXX file format

XXX expectations for lockers

XXX expectations for installers

Backwards Compatibility
=======================

[Describe potential impact and severity on pre-existing code.]


Security Implications
=====================

[How could a malicious user take advantage of this new feature?]


How to Teach This
=================

[How to teach users, new and experienced, how to apply the PEP to their work.]


Reference Implementation
========================

[Link to any existing implementation and details about its state, e.g. proof-of-concept.]


Rejected Ideas
==============

[Why certain ideas that were brought while discussing this PEP were not ultimately pursued.]


Open Issues
===========

[Any points that are still being decided/discussed.]


Footnotes
=========

[A collection of footnotes cited in the PEP, and a place to list non-inline hyperlink targets.]


Copyright
=========

This document is placed in the public domain or under the
CC0-1.0-Universal license, whichever is more permissive.


_Dependabot: https://docs.github.com/en/code-security/dependabot
_PDM: https://pypi.org/project/pdm/
_pip-tools: https://pypi.org/project/pip-tools/
_Poetry: https://python-poetry.org/
