PEP: <REQUIRED: pep number>
Title: A file format to list Python dependencies for installation reproducibility
Author: Brett Cannon <brett@python.org>
PEP-Delegate: <PEP delegate's real name>
Discussions-To: <REQUIRED: URL of current canonical discussion thread>
Status: Draft
Type: Standards Track
Topic: Packaging
Created: <date created on, in dd-mmm-yyyy format>
Post-History: <REQUIRED: dates, in dd-mmm-yyyy format, and corresponding links to PEP discussion threads>
Replaces: 665

Abstract
========

[A short (~200 word) description of the technical issue being addressed.]

This PEP proposes a new file format for specifying what dependencies to
(possibly) install into a Python environment for consitent installation
repoducibility. The format is designed to be human-readable but
machine-generated. Installers consuming the file should also not need to resolve
which listed dependencies to install, but instead evaluate each dependency in
question in isolation.


Motivation
==========

Currently, there is no standard way to specify what top-level dependencies one
would like to see installed into a Python environment and then subsequently
record what war eventually installed in a file (called a *lock file*).
Considering there are four well-known solutions to this problem in the
community (``pip freeze``, pip-tools_, Poetry_, and PDM_), there seems to be an
appetite for lock files in general.

Those tools also vary in what locking scenarios they approach. For instance,
``pip freeze`` and pip-tools only generate lock files for the current
environment while PDM and Poetry try to lock for *any* environment to some
degree. And none of them directly support locking to specific files to install
which can be important for some workflows. There's also concerns around secure
defaults in the face of supply chain attacks. Finally, not all the formats are
easy to audit to determine what what would be installed into an environment
ahead of time.

The lack of a standard also has some drawbacks. For instance, any tooling that
wants to work with lock files must choose which format to support, potentially
leaving users unsupported (e.g. if Dependabot_ chose not to support PDM.
support by cloud providers who can do dependency installations on your behalf,
etc.).


Rationale
=========

The file format is designed to be human-readable. This is
so that the contents of the file can be audited by a human to make sure no
undesired dependencies end up being included in the lock file. It is also to
facilitate understanding what would be installed if the lock file were to be
used without necessitating running a tool, once again to help with auditing.

The file format is also designed to not require a resolver at install time. Being
able to analyze dependencies in isolation from one another when listed in a lock
file provides a few benefits. First, it supports auditing by making it easy to
figure out if a certain dependency would be installed for a certain environment.
It should also lead to faster installs which are much more frequent than
creating a lock file. Finally, the four tools mentioned in the Motivation
section either already implement this approach of evaluating dependencies in
isolation or have suggested they could in
`Poetry's case <https://discuss.python.org/t/lock-files-again-but-this-time-w-sdists/46593/83>`__.

The format is also designed so that a *locker* which produces the lock file
and an *installer* which consumes the lock file can be separate tools. This
allows for situations such as cloud hosting providers to use their own installer
that's optimized for their system which is independent of what locker the user
used to create their lock file.


Locking Scenarios
-----------------

The lock file format is designed to support two locking scenarios.


Per-file Locking
''''''''''''''''

*Per-file locking* operates under the premise that one wants to install exact
same files in matching environments. As such, the lock file specifies the
requirements for an environment and then matches that environment requirements
with the files to install. There can be multiple environments specified in a
single file, each with their own set of files to install. By specifying the
exact files to install avoids needs performing a resolution to decide what to
install.

The motivation for this approach to locking is for those who have controlled
environments that they work with. For instance, if you have specific, controlled
development and production environments then you can use per-file locking to
make sure the **same** files are installed in either environment for everyone.

This is similar to what ``pip freeze`` and pip-tools_
support, but with more strictness of the exact files as well as incorporating
into the file format the ability to specify the locked files for multiple
environments.


Package Locking
'''''''''''''''

*Package locking* lists the packages and their versions that *may* apply to any
environment being installed for. The of packages and their version are evaluated
individually and independently from any other packages and versions listed in
the file. This allows installation to be linear -- read each package and version
and make an isolated decision as to whether it should be installed -- and thus
not require the installer to perform a resolution to decide what to install.

The motivation of this approach comes from
`PDM lock files <https://frostming.com/en/2024/pdm-lockfile/>`__. By listing the
potential packages and versions that may be installed, what packages may be
installed is controlled for in a way that's easy to reason about. This also
allows for not specifying the exact environments that would be supported by the
lock file so there's more flexibility and potentially easier
-- and thus faster -- lock generation. This approach supports scenarios like
open source projects that want to lock what people should use to build the
documentation as open source projects do not necessarily know upfront what
environments their contributors are working from.

One issue with this approach has with current packaging standards is that to be
wholly accurate with what dependencies could be installed, every distribution
file would need to be downloaded and analyzed. This is is not always practical
if a `project has a lot of distribution files <https://pypi.org/project/charset-normalizer/#files>`__,
especially when varying metadata between distribution files is considered rare.
As such, this PEP includes a proposal of a new `core metadata`_ field to specify
if metadata varies in any way between distribution files for a package version.

As already mentioned, this approach is supported by PDM_. Poetry_ has
`shown some interest <https://discuss.python.org/t/lock-files-again-but-this-time-w-sdists/46593/83>`__.


Specification
=============

Core Metadata 2.4
-----------------

A new core metadata version of 2.4 is to be introduced. This new version will
introduce a new field named `Differing-Metadata`. The absence of the field
indicates that the metadata is consistent across all distribution files for a
certain version. A value of ``all`` signifies **any** distribution file for a
specific version *may* have differing metadata. A value of ``sdist`` signifies
that only source distribution file for a specific version *may* have differing
metadata while all other files have the same metadata.

This should allow for the reading of the metadata from any distribution file to
know whether examining the other distribution files have the same or differing
metadata.


File Name
---------

A lock file MUST be named ``pylock.toml`` or match the regular expression
``f"pylock\.([A-Z0-9]|[A-Z0-9][A-Z0-9._-]*[A-Z0-9])\.toml"`` (the part between
``pylock.`` and ``.toml`` comes from
`valid non-normalized names <https://packaging.python.org/en/latest/specifications/name-normalization/#valid-non-normalized-names>`__
and their usage in :pep:`735`). The use of the ``.toml`` file extension is to
make syntax highlighting in editors easier and to reinforce the fact that the
file format is meant to be human-readable.


File Format
-----------

The format of the file is TOML_.

All keys listed below are required unless otherwise noted. If two keys are
mutually exclusive to one another, then one of the keys is required while the
other is disallowed.


``version``
'''''''''''

- String
- The version of the lock file format
- This PEP specifies the initial version -- and only valid vailue until future
  updates to the standard -- as ``"1.0"``


``dependencies``
'''''''''''''''

- Array of strings
- A listing the `dependency specifiers`_ that act as the input to the lock file,
  representing the direct, top-level dependencies to be installed


``[[file-lock]]``
'''''''''''''''''

- Mutually exclusive with ``[package-lock]``
- Array of tables
- The table's existence infers the use of the per-file lockinng approach
- An environment that meets all of the specified criteria in the table will be
  considered compatible with the environment that was locked for
- Lockers MUST NOT generate multiple ``[file-lock]`` tables which would be
  considered compatible for the same environment


``file-lock.name``
''''''''''''''''''

- String
- A unique name for the environment this table represents


``[file-lock.marker-values]``
'''''''''''''''''''''''''''''

- Optional
- Table of strings
- The keys represent the names of `environment markers`_ and the values are the
  values for those markers
- Compatibility is defined by the environment's values matching what is in the
  table
- Lockers SHOULD sort the keys lexicographically to minimize changes when
  updating the file


``file-lock.wheel-tags``
''''''''''''''''''''''''

- Optional
- Array of strings
- An unordered array of `wheel tags`_ which must be supported by the environment
- The array MAY not be exhaustive to allow for a smaller array as well as to
  help prevent multiple ``[[file-lock]]`` tables being compatible with the
  same environment
- Lockers SHOULD sort the keys lexicographically to minimize changes when
  updating the file
- Lockers MUST NOT include
  `compressed tag sets <https://packaging.python.org/en/latest/specifications/platform-compatibility-tags/#compressed-tag-sets>`__
  or duplicate tags for consistency across lockers and to simplify checking for
  compatibility


``[package-lock]``
''''''''''''''''''

- Table
- Mutually exclusive with ``[[file-lock]]``
- Signifies


``package-lock.requires-python``
''''''''''''''''''''''''''''''''

- String
- Holds the `version specifiers`_ for Python version compatibility


``[[package]]``
'''''''''''''''

- Array of tables
- Contains all data on the locked package versions
- Lockers MUST NOT list the same package and version more than once
- Lockers SHOULD record packages in order by ``package.name`` lexicographically
  and ``package.version`` by the sort order for `version specifiers`_
- Lockers SHOULD record keys in the same order as written in this PEP to
  minimmize changes when updating


``package.name``
''''''''''''''''

- String
- The `normalized name`_ of the package


``package.version``
'''''''''''''''''''

- String
- The version of the package


``package.project-details-url``
'''''''''''''''''''''''''''''''

- Optional
- String
- The `project detail` URL
- Useful for generating Packaging URLs (aka *PURLs*)


``package.marker``
''''''''''''''''''

- Optional
- String
- The `environment markers`_ expression which specifies whether this package and
  version applies to the environment
- Only applicable via ``[package-lock]`` and the package locking scenario
- The lack of this key means this package and version is required to be
  installed


``package.requires-python``
'''''''''''''''''''''''''''

- Optional
- String
- Holds the `version specifiers`_ for Python version compatibility for the
  package and version
- Useful for documenting why this package and version was included in the file
- It should not provide useful information for installers as it would be
  captured by `package-lock.requires-python` or isn't relevant when
  ``[[file-lock]]`` is used


``package.dependents``
''''''''''''''''''''''

- Optional
- Array of strings
- A record of the packages that depend on this package and version
- This is useful inn analyzing why a package happens to be listed in the file
  for auditing purposes
- This does not provide information which influences installers


``package.dependencies``
''''''''''''''''''''''''

- Optional
- Array of strings
- A record the dependencies of the package and version
- This is useful in analyzing why a package happens to be listed in the file
  for auditing purposes
- This does not provide information which influences the installer as
  ``[[file-lock]]`` specifies the exact files to use and ``[package-lock]``
  applicability is determined by ``package.marker``


``[[package.files]]``
'''''''''''''''''''''

- Must be specified if ``[package.vcs]`` is not
- Array of tables
- Tables can be written inline


``package.files.name``
''''''''''''''''''''''

- String
- File name


``package.files.hash``
''''''''''''''''''''''

- String
- The hash of the file contents
- The format is ``f"{hashname}={hashvalue}"`` which is the same as the used by
  the `Simple Repository API`_ and its HTML form
- Only a single hash value is used to allow the table to be written inline
- Using a single string to store both the hash algorithm and value instead of
  separate keys for the two values is to make the inline table shorter


``package.files.origin``
''''''''''''''''''''''''

- Optional
- String
- URI where the file was found when the lock file was generated


``package.files.lock``
'''''''''''''''''''''''''''

- Required when ``[[file-lock]]`` is used
- Array of strings
- An array of ``file-lock.name`` values which signify that the file is to be
  installed when the corresponding ``[[file-lock]]`` table applies to the
  environment
- There MUST only be a single file with any one ``file-lock.name`` entry per
  package, regardless of version


``[package.vcs]``
'''''''''''''''''

- Must be specified if ``[[package.files]]`` is not
- Table representing the version control system containing the package and
  version


``package.vcs.type``
''''''''''''''''''''

- String
- The type of version control system used
- The valid values are specified by the
  `registered VCSs <https://packaging.python.org/en/latest/specifications/direct-url-data-structure/#registered-vcs>`__
  of the direct URL data structure


``package.vcs.origin``
''''''''''''''''''''''

- String
- The URI of where the repository was located when the lock file was generated


``package.vcs.commit``
''''''''''''''''''''''

- String
- The commit ID for the repository which represents the package and version


``package.vcs.lock``
'''''''''''''''''''''''''

- Required when ``[[file-lock]]`` is used
- An array of strings
- An array of ``file-lock.name`` values which signify that the repository at the
  specified commit is to be installed when the corresponding ``[[file-lock]]``
  table applies to the environment
- A name in the array may only appear if no file listed in
  ``package.files.lock`` contains the name for the same package, regardless of
  version


``[[package.build-requires]]``
''''''''''''''''''''''''''''''

- Optional
- An array of tables whose structure matches that of ``[[package]]``
- Each entry represents a package and version to use when building the
  enclosing package and version
- Selection of which entries to use for an environment as the same as
  ``[[package]]`` itself, albeit only applying when installing build back-end
  dependencies
- This helps with reproducibility of the building of a package by recording
  either what was or would have been used if the locker needed to build the
  package


``[package.tool]``
''''''''''''''''''

- Optional
- Same usage as that of the equivalent table from the
  `pyproject.toml specification`_


``[tool]``
''''''''''

- Optional
- Same usage as that of the equivalent table from the
  `pyproject.toml specification`_


Expectations for Lockers
------------------------

- When creating a lock file for ``[package-lock]`` and a package and version are
  not using core metadata 2.4 as proposed by this PEP, the locker SHOULD read
  the metadata of all files listed in ``[[package.files]]`` to make sure all
  potential metadata cases are covered
- If a locker chooses not to check every file, the tool MUST either provide the
  user with the option to have all files checked (whether that is opt-in or out
  is left up to the tool), or the user is somehow notified that such a
  standards-violating shortcut is being taken (whether this is by documentation
  or at runtime is left to the tool)
- Lockers MAY want to provide a way to let users provide the information
  necessary to install for multiple environments at once when doing per-file
  locking, e.g. supporting a JSON file format which specifies wheel tags and
  marker values much like in ``[[file-lock]]`` for which multiple files can be
  specified, which could then be directly recorded in the corresponding
  ``[[file-lock]]`` table

.. code-block:: JSON

    {
        "marker-values": {...}
        "wheel-tags": [...]
    }


Expectations for Installers
---------------------------

- Installers MAY support installation of non-binary files
  (i.e. source distributions and VCS)
- Installers MUST provide a way to avoid non-binary file installation for
  reproducibility and security
- Installers SHOULD make it opt-in for using non-binary file installation for a
  secure-by-default approach


Installing for per-file locking
'''''''''''''''''''''''''''''''

An example workflow is:

- Iterate through each ``[[file-lock]]`` table to find the one that applies to
  the environment being installed for
- If no compatible environment is found an error MUST be raised
- For the compatible environment, iterate through each entry in ``[[package]]``
- For each ``[[package]]`` entry, iterate through ``[[package.files]]`` to look
- for any files with ``file-lock.name`` listed in ``package.files.lock``
- If a file is found, install it and move on to the next ``[[package]]`` entry
- If no file is found then check if ``package.vcs.lock`` contains a match (no
  match is acceptable)
- If a ``[[package.files]]`` contains multiple matching entries an error MUST
  be raised due to ambiguity for what is to be installed
- If multiple ``[[package]]`` entries for the same package have matching files
  an error MUST be raised due to ambiguity for what is to be installed
- Find and verify the selected files and/or CVS entries based on their hash or
  commit ID as appropriate
- If a source distribution or VCS was selected and
  ``[[package.build-requires]]`` exists, then repeat the above process as
  appropriate to install the build dependencies necessary to build the package


Installing for package locking
''''''''''''''''''''''''''''''

An example workflow is:

- Verify that the environment is compatible with `package-lock.requires-python`;
  if it isn't an error MUST be raised
- Iterate through each entry in ``[package]]``
- For each entry, if there's a ``package.marker`` key, evaluate the expression
  - If the expression is false, then move on
  - Otherwise the package entry must be installed
- Iterate through the files listed in ``[[package.files]]``, looking for the
  "best" file to install
- If no file is found, check for ``[package.vcs]``
- If not match is found, an error MUST be raised
- Find and verify the selected files and/or CVS entries based on their hash or
  commit ID as appropriate
- If the match is a source distribution or VCS and
  ``[[package.build-requires]]`` is provided, repeat the above as appropriate to
  build the package


Backwards Compatibility
=======================

[Describe potential impact and severity on pre-existing code.]


Security Implications
=====================

[How could a malicious user take advantage of this new feature?]


How to Teach This
=================

[How to teach users, new and experienced, how to apply the PEP to their work.]


Reference Implementation
========================

[Link to any existing implementation and details about its state, e.g. proof-of-concept.]


Rejected Ideas
==============

[Why certain ideas that were brought while discussing this PEP were not ultimately pursued.]


Open Issues
===========

[Any points that are still being decided/discussed.]


Footnotes
=========

[A collection of footnotes cited in the PEP, and a place to list non-inline hyperlink targets.]


Copyright
=========

This document is placed in the public domain or under the
CC0-1.0-Universal license, whichever is more permissive.


_core metadata: https://packaging.python.org/en/latest/specifications/core-metadata/
_Dependabot: https://docs.github.com/en/code-security/dependabot
_dependency specifiers: https://packaging.python.org/en/latest/specifications/dependency-specifiers/
_environment markers: https://packaging.python.org/en/latest/specifications/dependency-specifiers/#environment-markers
_normalized name: https://packaging.python.org/en/latest/specifications/name-normalization/#name-normalization
_PDM: https://pypi.org/project/pdm/
_pip-tools: https://pypi.org/project/pip-tools/
_Poetry: https://python-poetry.org/
_project detail: https://packaging.python.org/en/latest/specifications/simple-repository-api/#project-detail
_pyproject.toml specification: https://packaging.python.org/en/latest/specifications/pyproject-toml/#pyproject-toml-specification
_Simple Repository API: https://packaging.python.org/en/latest/specifications/simple-repository-api/
_version specifiers: https://packaging.python.org/en/latest/specifications/version-specifiers/
_wheel tags: https://packaging.python.org/en/latest/specifications/platform-compatibility-tags/
